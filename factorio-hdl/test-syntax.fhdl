module register_bank <number_of_registers> (
    net(red) io [
        write_addr
        write_value
        write_trigger
        read_1_addr
        read_1_value
        read_2_addr
        read_2_value
    ]
    net(green) foo [
        write_trigger # this is the same as in io
        other_signal
    ]
) {
    net(red) write_value_neg [memory]
    {
        net(red) tmp [write_value]
        tmp[write_value] <- io[write_trigger == 1] value
        write_value_neg[memory] <- tmp[write_value * -1] 
    }
    loop address from 0 to number_of_registers {
        register<address>(
            io[read_1_addr read_2_addr write_trigger] 
            read_1[memory] 
            read_2[memory] 
            write_value_neg[memory]
        )
        io[memory] <- 1
        foo = 2 # TODO: arithmetic expressions
    }
    # TODO: arrays
    # net(red) with_array_array(0 to 4) [foo(0 to number_of_registers)]
}

module register <address> (
    net(red) io [read_1_addr read_2_addr write_trigger]
    net(red) read_1 [memory]
    net(red) read_2 [memory]
    net(red) write_value_neg [memory]
) {
    net(green) memory [memory]
    # Memory loop
    memory[memory] <- memory[memory + 0]
    # Readout
    read_1[memory] <- (io memory)[read_1_addr == address] value
    read_2[memory] <- (io memory)[read_2_addr == address] value
    # Writeback 
    net(red) override [write_trigger]
    # Check write address
    override[write_trigger] <- io[write_addr == address] value 
    # Clear previous value, add new one
    override[memory] <- (write_value_neg memory)[memory * -1]
    # Check trigger
    memory[memory] <- override[write_trigger == 1] value
}