module register_bank <number_of_registers> (
    net(red) io [
        write_addr
        write_value
        write_trigger
        read_1_addr
        read_1_value
        read_2_addr
        read_2_value
    ]
    net(green) foo [
        write_trigger # this is the same as in io
        other_signal
    ]
) {
    net(red) write_value_neg [memory]
    {
        net(red) tmp [write_value]
        io[write_trigger == 1] -> value tmp[write_value]
        tmp[write_value * -1] -> write_value_neg[memory]
    }
    loop address from 0 to number_of_registers {
        register<address>(
            id[read_1_addr read_2_addr write_trigger] 
            read_1[memory] 
            read_2[memory] 
            write_value_neg[memory]
        )
    }
}

module register <address> (
    net(red) io [read_1_addr read_2_addr write_trigger]
    net(red) read_1 [memory]
    net(red) read_2 [memory]
    net(red) write_value_neg [memory]
) {
    net(green) memory [memory]
    # Memory loop
    memory[memory + 0] -> memory[memory]
    # Readout
    (io memory)[read_1_addr == address] -> value read_1[memory]
    (io memory)[read_2_addr == address] -> value read_2[memory]
    # Writeback 
    net(red) override [write_trigger]
    # Check write address
    io[write_addr == address] -> value override[write_trigger]
    # Clear previous value, add new one
    (write_value_neg memory)[memory * -1] -> override[memory]
    # Check trigger
    override[write_trigger == 1] -> value memory[memory]
}